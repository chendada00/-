1. **物理层（Physical Layer）**：
   - 功能：这一层处理物理介质和数据传输的基本物理特性，例如电压、电流、光信号等。
   - 常用协议和设备：Ethernet、USB、光纤、双绞线、集线器（Hub）。
2. **数据链路层（Data Link Layer）**：
   - 功能：负责数据的帧化、物理地址的解析、流量控制和错误检测和纠正。
   - 常用协议和设备：Ethernet、Wi-Fi、MAC地址、交换机（Switch）、网桥（Bridge）。
3. **网络层（Network Layer）**：
   - 功能：路由选择、数据包的寻址、跨不同网络的数据传输。
   - 常用协议和设备：IP（IPv4、IPv6）、路由器（Router）、OSPF、BGP。
4. **传输层（Transport Layer）**：
   - 功能：提供端到端的数据传输和可靠性，负责数据的分段和重新组装，错误检测和纠正。
   - 常用协议：TCP、UDP。
5. **会话层（Session Layer）**：
   - 功能：管理通信会话，建立、维护和终止连接。
   - 常用软件：NetBIOS、RPC（Remote Procedure Call）。
6. **表示层（Presentation Layer）**：
   - 功能：数据格式转换、数据加密、数据压缩、字符编码等，以确保不同系统之间的数据互通。
   - 常用协议：SSL/TLS、ASCII、EBCDIC。
7. **应用层（Application Layer）**：
   - 功能：为用户提供网络服务和应用，包括文件传输、电子邮件、网页浏览等。
   - 常用协议：HTTP、FTP、SMTP、POP3、IMAP、DNS。



1.原型模型：基于这样一种客观事实：并非所有的需求在系统开发之前都能准确地说明和定义。采用了``动态定义需求的方法``。它适用于需求不明确的开发环境。



2.瀑布模型：严格遵循软件生命周期各阶段的固定顺序，一个阶段完成再进入另一个阶段。其优点是：可以使过程比较规范化，有利于评审；缺点在于：过于理想，缺乏灵活性，容易产生需求偏差。所以瀑布模型的应用场合为：``需求明确的项目``、二次开发项目以及与原型法配合使用。



3.演化模型：它将软件系统的开发过程比作生物进化，通过多次迭代和演化来构建软件系统。演化模型的一个主要特点是它``允许在项目的不同阶段进行变更和扩展``，以适应新的需求和发现的问题。这个模型的主要思想是，软件系统不断演化，就像生物进化一样。



4.增量模型：

- 增量模型将项目划分为多个增量，每个增量都包含一个独立的部分功能。
- 每个增量都经历完整的开发周期，然后逐渐组合到一个完整的系统中。
- ``适用于大型项目，可以更早地交付部分功能``。



5.螺旋模型：``结合了瀑布模型和演化模型的优点``，最主要的特点在于``加入了风险分析``。它是由制定计划、风险分析、实施工程、客户评估这一循环组成的，它最初从概念项目开始第一个螺旋。



6.喷泉模型：主要用于描述面向对象的开发过程，最核心的特点是迭代。所有的``开发活动没有明显的边界``，允许各种开发活动交叉进行。



7.V模型：``强调开发过程中测试贯穿始终``；



8.UP：既是一个统一的软件开发过程，是一个通用过程框架，可以应付种类广泛的软件系统、不同的应用领域、不同的组织类型、不同的性能水平和不同的项目规模。UP是基于构件的，这意味着利用它开发的软件系统是由构件构成的，构件之间通过定义良好的接口相互联系。在准备软件系统所有蓝图的时候，UP使用的是统一建模语言UML。与其他软件过程相比，UP具有三个显著的特点：用例驱动、以基本架构为中心、迭代和增量。



1. 创建型模式（Creational Patterns）：
   这些模式关注对象的创建机制，以确保在系统中适当地创建和配置对象。
   - 单例模式（Singleton Pattern）：确保一个类只有一个实例，并提供全局访问点。
   - 工厂方法模式（Factory Method Pattern）：定义一个创建对象的接口，但让子类决定具体实例化哪个类。
   - 抽象工厂模式（Abstract Factory Pattern）：提供一个接口，用于创建一系列相关或依赖对象的家族，而不需要指定具体类。
   - 建造者模式（Builder Pattern）：将一个复杂对象的构建与其表示分离，使相同的构建过程可以创建不同的表示。
   - 原型模式（Prototype Pattern）：通过复制现有对象创建新对象，而不是创建新的实例。
2. 结构型模式（Structural Patterns）：
   这些模式关注对象之间的组合，以形成更大的结构。
   - 适配器模式（Adapter Pattern）：将一个接口转换成客户端希望的另一个接口，以便客户端可以调用不同接口的对象。
   - 装饰器模式（Decorator Pattern）：动态地为对象添加额外的职责，而不改变其接口。
   - 桥接模式（Bridge Pattern）：将抽象部分与其实现部分分离，以便它们可以独立变化。
   - 组合模式（Composite Pattern）：将对象组合成树结构以表示部分-整体层次结构。
   - 外观模式（Facade Pattern）：为子系统提供一个一致的接口，以简化与子系统的交互。
   - 享元模式（Flyweight Pattern）：共享细粒度对象，以减少内存和提高性能。
   - 代理模式（Proxy Pattern）：为其他对象提供一个代理以控制对这个对象的访问。
3. 行为型模式（Behavioral Patterns）：
   这些模式关注对象之间的职责分配，以及如何在对象之间进行通信。
   - 责任链模式（Chain of Responsibility Pattern）：通过链式传递请求，解决发送者和接收者之间的耦合。
   - 命令模式（Command Pattern）：将请求封装为对象，以使调用操作的对象参数化、排队、记录和撤销操作。
   - 解释器模式（Interpreter Pattern）：为语言创建解释器，用于解释特定的语法。
   - 迭代器模式（Iterator Pattern）：提供一种方法依次访问聚合对象的元素，而不暴露其内部表示。
   - 中介者模式（Mediator Pattern）：定义一个封装一组对象交互的对象，促进松散耦合。
   - 备忘录模式（Memento Pattern）：在不破坏封装的前提下，捕获和恢复对象的内部状态。
   - 观察者模式（Observer Pattern）：定义对象之间的一对多依赖关系，使一个对象状态改变时，所有依赖对象都得到通知。
   - 状态模式（State Pattern）：允许对象在其内部状态改变时改变其行为。
   - 策略模式（Strategy Pattern）：定义一系列算法，将其封装成独立的策略对象，并在运行时选择策略。
   - 模板方法模式（Template Method Pattern）：定义算法的骨架，但将一些步骤的实现延迟到子类。
   - 访问者模式（Visitor Pattern）：在不改变对象结构的前提下，定义作用于对象结构中的元素的新操作。
   每种设计模式都有其独特的应用场景和优点，可以根据问题的性质和需求来选择适当的模式。这些设计模式可以提高代码的可维护性、可扩展性和可重用性。



1. **分治法（Divide and Conquer）**：
   - 分治法是一种将问题划分为更小的子问题，然后递归地解决这些子问题，最后将子问题的解合并以得到原问题的解的算法。
   - 典型的例子包括归并排序和快速排序。在这些算法中，原问题被分解为子数组的排序问题，然后合并排序后的子数组以获得整体排序结果。
2. **动态规划法（Dynamic Programming）**：
   - 动态规划法是一种通过将问题分解为更小的子问题并存储子问题的解来解决复杂问题的方法。
   - 典型应用包括最短路径问题、背包问题和斐波那契数列计算。动态规划算法通常使用表格或矩阵来存储中间结果，以避免重复计算。
3. **贪心法（Greedy Algorithm）**：
   - 贪心法是一种每次选择局部最优解的策略，以期望最终获得全局最优解。
   - 典型应用包括霍夫曼编码和最小生成树算法，如Prim和Kruskal算法。贪心算法通常易于理解和实现，但不一定总是产生最优解。
4. **回溯法（Backtracking）**：
   - 回溯法是一种通过尝试不同的选择并在不满足条件时回溯到先前的状态来解决问题的方法。
   - 典型应用包括八皇后问题和旅行推销员问题。回溯算法通常用于组合优化和搜索问题，它会尝试所有可能的解决方案。
5. **分支限界法（Branch and Bound）**：
   - 分支限界法是一种通过分支问题并定义上下界来限制搜索空间的方法，以找到最优解。
   - 典型应用包括0/1背包问题和旅行推销员问题。分支限界法通常结合了分治和贪心思想，以提高问题的解决效率。



###### 类图

1.泛化(继承)：是一种继承关系，表示一般与特殊的关系，它指定了子类如何特化父类的所有特征和行为。例如：老虎是动物的一种，即有老虎的特性也有动物的共性。

<img src="https://gitee.com/cheebo/chart-bed/raw/master/img/image-20231024094841708.png" alt="image-20231024094841708" style="zoom: 33%;float:right" />

2.实现：在这里插入图片描述是一种类与接口的关系，表示类是接口所有特征和行为的实现.

<img src="https://gitee.com/cheebo/chart-bed/raw/master/img/image-20231024094945819.png" alt="image-20231024094945819" style="zoom: 33%;float:right" />

3.依赖：一个类依赖于另一个类的定义。一般而言，依赖关系在Java语言中体现为成员变量、局域变量、方法的形参、方法返回值，或者对静态方法的调用

<img src="https://gitee.com/cheebo/chart-bed/raw/master/img/image-20231024095311518.png" alt="image-20231024095311518" style="zoom: 33%;float:right" />

4.关联：是一种拥有的关系，它使一个类知道另一个类的属性和方法；如：老师与学生

<img src="https://gitee.com/cheebo/chart-bed/raw/master/img/image-20231024095421391.png" alt="image-20231024095421391" style="zoom: 33%;float:right" />

5.聚合：聚合是一种较弱的关联关系，表示一个对象包含另一个对象，``但包含的对象的生命周期不一定依赖于包含对象。``
例如：``一个大学（整体）包含多个学生（部分）``。学生可以毕业或转学，但他们的生命周期不仅仅取决于大学的存在。

<img src="https://gitee.com/cheebo/chart-bed/raw/master/img/image-20231024095551168.png" alt="image-20231024095551168" style="zoom: 33%;float:right" />

6.组合：组合是一种较强的关联关系，表示一个对象包含另一个对象，``且包含的对象的生命周期依赖于包含对象``。如果包含对象被销毁，那么它所包含的对象也会被销毁。

例如：``一辆汽车（整体）包括引擎、轮胎、座位等部分``。如果汽车被销毁，那么引擎、轮胎、座位等部分也将被销毁

<img src="https://gitee.com/cheebo/chart-bed/raw/master/img/image-20231024095724710.png" alt="image-20231024095724710" style="zoom: 33%;float:right" />

###### 用例图

1.包含关系（include）：

- 用例图中的包含关系表示一个用例包含了另一个用例，即包含用例需要在执行过程中引入被包含用例的行为。
- 通常用带有虚线箭头的箭头表示，箭头从包含用例指向被包含用例。箭头的标签描述了包含用例的条件。

- 这种关系表示被包含用例的执行是可选的，它会在包含用例的执行中根据条件来引入。

2.扩展关系（extend）：

- 扩展关系表示一个用例可以在一定条件下扩展另一个用例的行为，即扩展用例提供了在基础用例执行时可能发生的额外行为。
- 通常用带有虚线箭头的箭头表示，箭头从扩展用例指向被扩展用例。箭头的标签描述了扩展用例的条件。
- 这种关系表示扩展用例的执行是可选的，它只有在满足条件时才会被触发。

3.泛化关系（generalize）：

- 泛化关系表示用例之间的继承关系，其中一个用例（子用例）继承了另一个用例（父用例）的行为。
- 用实线箭头表示，箭头从子用例指向父用例。
- 子用例继承了父用例的特征和行为，通常用于表示用例的层次结构。